{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Module PgRouting # Lizmap 3.5 minium install the module. configure the QGIS project. Funded by CRIGE PACA in France","title":"Home"},{"location":"#module-pgrouting","text":"Lizmap 3.5 minium install the module. configure the QGIS project. Funded by CRIGE PACA in France","title":"Module PgRouting"},{"location":"CHANGELOG/","text":"Changelog # Unreleased # Fixed # Improve compatibility with Lizmap 3.6 0.3.0 - 2022-10-13 # Added # Experimental compatibility with Lizmap 3.6 Fixed # The module is now compatible with Lizmap 3.5.6 0.2.1 - 2021-10-19 # Drop previous roadmap when no routes were found in the database and display a message 0.2.0 - 2021-10-15 # Add some checks for SQL query results Add a PHP class to check the configuration (database extension and structure, required QGIS project layers) Improve the import script example for French IGN BdTopo Improve the spatial query performance Add a default label 'unnamed road' in the pgRouting dock when the edge has no label Add a button to reset start and end point 0.1.0 - 2021-06-22 # First version of the module","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"Unreleased"},{"location":"CHANGELOG/#fixed","text":"Improve compatibility with Lizmap 3.6","title":"Fixed"},{"location":"CHANGELOG/#030-2022-10-13","text":"","title":"0.3.0 - 2022-10-13"},{"location":"CHANGELOG/#added","text":"Experimental compatibility with Lizmap 3.6","title":"Added"},{"location":"CHANGELOG/#fixed_1","text":"The module is now compatible with Lizmap 3.5.6","title":"Fixed"},{"location":"CHANGELOG/#021-2021-10-19","text":"Drop previous roadmap when no routes were found in the database and display a message","title":"0.2.1 - 2021-10-19"},{"location":"CHANGELOG/#020-2021-10-15","text":"Add some checks for SQL query results Add a PHP class to check the configuration (database extension and structure, required QGIS project layers) Improve the import script example for French IGN BdTopo Improve the spatial query performance Add a default label 'unnamed road' in the pgRouting dock when the edge has no label Add a button to reset start and end point","title":"0.2.0 - 2021-10-15"},{"location":"CHANGELOG/#010-2021-06-22","text":"First version of the module","title":"0.1.0 - 2021-06-22"},{"location":"CONTRIBUTING/","text":"Contribution # You can contribute to the SQL code or the frontend Lizmap interface.","title":"Contribution"},{"location":"CONTRIBUTING/#contribution","text":"You can contribute to the SQL code or the frontend Lizmap interface.","title":"Contribution"},{"location":"changelog/","text":"Changelog # Unreleased # Fixed # Improve compatibility with Lizmap 3.6 0.3.0 - 2022-10-13 # Added # Experimental compatibility with Lizmap 3.6 Fixed # The module is now compatible with Lizmap 3.5.6 0.2.1 - 2021-10-19 # Drop previous roadmap when no routes were found in the database and display a message 0.2.0 - 2021-10-15 # Add some checks for SQL query results Add a PHP class to check the configuration (database extension and structure, required QGIS project layers) Improve the import script example for French IGN BdTopo Improve the spatial query performance Add a default label 'unnamed road' in the pgRouting dock when the edge has no label Add a button to reset start and end point 0.1.0 - 2021-06-22 # First version of the module","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#fixed","text":"Improve compatibility with Lizmap 3.6","title":"Fixed"},{"location":"changelog/#030-2022-10-13","text":"","title":"0.3.0 - 2022-10-13"},{"location":"changelog/#added","text":"Experimental compatibility with Lizmap 3.6","title":"Added"},{"location":"changelog/#fixed_1","text":"The module is now compatible with Lizmap 3.5.6","title":"Fixed"},{"location":"changelog/#021-2021-10-19","text":"Drop previous roadmap when no routes were found in the database and display a message","title":"0.2.1 - 2021-10-19"},{"location":"changelog/#020-2021-10-15","text":"Add some checks for SQL query results Add a PHP class to check the configuration (database extension and structure, required QGIS project layers) Improve the import script example for French IGN BdTopo Improve the spatial query performance Add a default label 'unnamed road' in the pgRouting dock when the edge has no label Add a button to reset start and end point","title":"0.2.0 - 2021-10-15"},{"location":"changelog/#010-2021-06-22","text":"First version of the module","title":"0.1.0 - 2021-06-22"},{"location":"configuration/","text":"Configuration # Data integration # Once the module is installed, you have to fill the tables with your data, for example from a road table containing linestrings. pgrouting.nodes : nodes of the routing graph, for example the start and end nodes of the linestrings, pgrouting.edges : edges of the graph, which mean the links between the nodes, characterized by their source and target nodes, pgrouring.routing_poi : optional points of interests along the roads (point geometries) We presented below an example of data import based on the French IGN BDTopo road layer loaded in a table bdtopo.troncon_de_route . The first step is to import the data to your PostgreSQL database. We recommend to use another schema, such as bdtopo . The second step is to add data in the pgrouting nodes and edges tables, taken from the source table. Import your source data in PostgreSQL # Your source data must be topological , which means roads must be cut at each physical intersection and do not overlap other roads. graph TD; A-->B; A-->C; A-->E; B-->D; B-->C; C-->D; C-->E; D-->E; You can use ogr2ogr to import your data in batch, for example with 1 ogr2ogr -progress --config PG_USE_COPY YES -f PostgreSQL PG: 'service=lizmap-pgrouting active_schema=bdtopo' -lco DIM = 2 -append -lco GEOMETRY_NAME = geom -lco FID = gid -nln bdtopo.troncon_de_route -t_srs EPSG:2154 -nlt PROMOTE_TO_MULTI \"TRONCON_DE_ROUTE.shp\" In the example above, the -append option allows to import several SHP inside the same table if needed. This command will add a gid column as the primary key. Be careful to delete the duplicate geometries, for example when you import data from multiple source files with overlapping data (such as in the French IGN BDTOPO \"d\u00e9partement\" extracts). You can use this kind of query to remove the duplicates based on the primary key gid and the IGN BDTOPO key id : 1 DELETE FROM bdtopo . troncon_de_route AS a USING bdtopo . troncon_de_route AS b WHERE a . gid < b . gid AND a . id = b . id ; Import the road data into PgRouting graph (nodes and edges) # Depending on your source layer, you might not have the same field names. Here, geom is the geometry field, sens is the direction field, nom_1_g is the road name field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 BEGIN ; -- Copy data from the route source table -- For example: bdtopo.troncon_de_route -- to create the temporary edges -- with added start and end point point geometries. DROP TABLE IF EXISTS temp_edges ; CREATE TABLE temp_edges AS WITH source AS ( SELECT -- Stores the original data inside a JSON field to_jsonb ( t . * ) AS raw_data , -- Move the geometries nodes to a grid ST_SnapToGrid ( ST_geometryN ( geom , 1 ), 0 . 1 ) AS geom -- bdtopo.troncon_de_route is the source road table FROM bdtopo . troncon_de_route AS t WHERE TRUE ) SELECT source . * , -- get the start point ST_StartPoint ( geom ) AS start_point , -- get the end point ST_EndPoint ( geom ) AS end_point FROM source ; -- Create the needed indexes CREATE INDEX ON temp_edges USING GIST ( geom ); CREATE INDEX ON temp_edges USING GIST ( start_point ); CREATE INDEX ON temp_edges USING GIST ( end_point ); -- Create the temporary nodes from the start and end points DROP TABLE IF EXISTS temp_nodes ; CREATE TABLE temp_nodes AS WITH union_start_end AS ( SELECT raw_data ->> 'id' AS start_of , NULL AS end_of , start_point AS geom FROM temp_edges UNION ALL SELECT NULL AS start_of , raw_data ->> 'id' AS end_of , end_point AS geom FROM temp_edges ), distinct_nodes AS ( SELECT json_agg ( DISTINCT start_of ) FILTER ( WHERE start_of IS NOT NULL ) AS start_of , json_agg ( DISTINCT end_of ) FILTER ( WHERE end_of IS NOT NULL ) AS end_of , geom FROM union_start_end GROUP BY geom ) SELECT * FROM distinct_nodes ; CREATE INDEX ON temp_nodes USING GIST ( geom ); -- Insert them in the pgrouting.nodes table TRUNCATE pgrouting . nodes RESTART IDENTITY CASCADE ; INSERT INTO pgrouting . nodes ( geom ) SELECT geom FROM temp_nodes ; -- Insert the temporary edges into the pgrouting.edges table -- with additional information about nodes, costs, etc. TRUNCATE pgrouting . edges RESTART IDENTITY CASCADE ; INSERT INTO pgrouting . edges ( label , length , source , target , cost , reverse_cost , source_data , geom ) SELECT DISTINCT -- label of the edge e . raw_data ->> 'nom_1_g' AS label , -- length ST_length ( e . geom ) AS \"length\" , -- start and end nodes id ns . id , ne . id , -- cost based on the length CASE WHEN e . raw_data ->> 'sens' in ( 'Sans objet' , 'Double sens' , 'Sens direct' ) THEN ST_length ( e . geom ) ELSE - 1 END AS cost , -- reverse cost based on the length CASE WHEN e . raw_data ->> 'sens' in ( 'Sans objet' , 'Double sens' , 'Sens inverse' ) THEN ST_length ( e . geom ) ELSE - 1 END AS reverse_cost , -- Keep some useful columns from the source table jsonb_build_object ( 'id' , e . raw_data -> 'id' , 'nature' , e . raw_data -> 'nature' , 'importance' , e . raw_data -> 'importance' , 'etat' , e . raw_data -> 'etat' , 'largeur' , e . raw_data -> 'largeur' , 'prive' , e . raw_data -> 'prive' , 'sens' , e . raw_data -> 'sens' , 'vit_moy_vl' , e . raw_data -> 'vit_moy_vl' , 'acces_vl' , e . raw_data -> 'acces_vl' ) AS source_data , -- geometry. Needed for the astar route engine e . geom FROM temp_edges AS e LEFT JOIN pgrouting . nodes AS ns -- = is faster than ST_Equals ON ns . geom = e . start_point LEFT JOIN pgrouting . nodes AS ne ON ne . geom = e . end_point ; -- Drop the temporary tables DROP TABLE IF EXISTS temp_nodes ; DROP TABLE IF EXISTS temp_edges ; COMMIT ; -- VACUUM and analyse VACUUM ANALYSE pgrouting . nodes ; VACUUM ANALYSE pgrouting . edges ; Import data in the POI tables (optional) # Here is an example based on a points of interest layer loaded in a table called your_schema.point_of_interest . This query fill the pgrouting.routing_poi table. In the SELECT you can replace the fields by your fields of your point of interest layer. 1 2 3 INSERT INTO pgrouting . routing_poi ( label , type , description , geom ) SELECT poi . label , poi . type , poi . description , poi . geom FROM your_schema . point_of_interest AS poi ; In QGIS # Configure the QGIS project # To use the pgrouting module in Lizmap Web Client you must first configure a QGIS project : We offer you here a basic project which contains only the layers required and configured for Lizmap. If you want create your project or use another existing project to use this module: Add the Edges and Nodes layers The QGIS project must be called pgrouting.qgs You must then create a configuration for Lizmap with the Lizmap plugin . No specific configuration is needed for the module. You can configure like you want or just click on the apply button.","title":"Configuraton"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#data-integration","text":"Once the module is installed, you have to fill the tables with your data, for example from a road table containing linestrings. pgrouting.nodes : nodes of the routing graph, for example the start and end nodes of the linestrings, pgrouting.edges : edges of the graph, which mean the links between the nodes, characterized by their source and target nodes, pgrouring.routing_poi : optional points of interests along the roads (point geometries) We presented below an example of data import based on the French IGN BDTopo road layer loaded in a table bdtopo.troncon_de_route . The first step is to import the data to your PostgreSQL database. We recommend to use another schema, such as bdtopo . The second step is to add data in the pgrouting nodes and edges tables, taken from the source table.","title":"Data integration"},{"location":"configuration/#import-your-source-data-in-postgresql","text":"Your source data must be topological , which means roads must be cut at each physical intersection and do not overlap other roads. graph TD; A-->B; A-->C; A-->E; B-->D; B-->C; C-->D; C-->E; D-->E; You can use ogr2ogr to import your data in batch, for example with 1 ogr2ogr -progress --config PG_USE_COPY YES -f PostgreSQL PG: 'service=lizmap-pgrouting active_schema=bdtopo' -lco DIM = 2 -append -lco GEOMETRY_NAME = geom -lco FID = gid -nln bdtopo.troncon_de_route -t_srs EPSG:2154 -nlt PROMOTE_TO_MULTI \"TRONCON_DE_ROUTE.shp\" In the example above, the -append option allows to import several SHP inside the same table if needed. This command will add a gid column as the primary key. Be careful to delete the duplicate geometries, for example when you import data from multiple source files with overlapping data (such as in the French IGN BDTOPO \"d\u00e9partement\" extracts). You can use this kind of query to remove the duplicates based on the primary key gid and the IGN BDTOPO key id : 1 DELETE FROM bdtopo . troncon_de_route AS a USING bdtopo . troncon_de_route AS b WHERE a . gid < b . gid AND a . id = b . id ;","title":"Import your source data in PostgreSQL"},{"location":"configuration/#import-the-road-data-into-pgrouting-graph-nodes-and-edges","text":"Depending on your source layer, you might not have the same field names. Here, geom is the geometry field, sens is the direction field, nom_1_g is the road name field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 BEGIN ; -- Copy data from the route source table -- For example: bdtopo.troncon_de_route -- to create the temporary edges -- with added start and end point point geometries. DROP TABLE IF EXISTS temp_edges ; CREATE TABLE temp_edges AS WITH source AS ( SELECT -- Stores the original data inside a JSON field to_jsonb ( t . * ) AS raw_data , -- Move the geometries nodes to a grid ST_SnapToGrid ( ST_geometryN ( geom , 1 ), 0 . 1 ) AS geom -- bdtopo.troncon_de_route is the source road table FROM bdtopo . troncon_de_route AS t WHERE TRUE ) SELECT source . * , -- get the start point ST_StartPoint ( geom ) AS start_point , -- get the end point ST_EndPoint ( geom ) AS end_point FROM source ; -- Create the needed indexes CREATE INDEX ON temp_edges USING GIST ( geom ); CREATE INDEX ON temp_edges USING GIST ( start_point ); CREATE INDEX ON temp_edges USING GIST ( end_point ); -- Create the temporary nodes from the start and end points DROP TABLE IF EXISTS temp_nodes ; CREATE TABLE temp_nodes AS WITH union_start_end AS ( SELECT raw_data ->> 'id' AS start_of , NULL AS end_of , start_point AS geom FROM temp_edges UNION ALL SELECT NULL AS start_of , raw_data ->> 'id' AS end_of , end_point AS geom FROM temp_edges ), distinct_nodes AS ( SELECT json_agg ( DISTINCT start_of ) FILTER ( WHERE start_of IS NOT NULL ) AS start_of , json_agg ( DISTINCT end_of ) FILTER ( WHERE end_of IS NOT NULL ) AS end_of , geom FROM union_start_end GROUP BY geom ) SELECT * FROM distinct_nodes ; CREATE INDEX ON temp_nodes USING GIST ( geom ); -- Insert them in the pgrouting.nodes table TRUNCATE pgrouting . nodes RESTART IDENTITY CASCADE ; INSERT INTO pgrouting . nodes ( geom ) SELECT geom FROM temp_nodes ; -- Insert the temporary edges into the pgrouting.edges table -- with additional information about nodes, costs, etc. TRUNCATE pgrouting . edges RESTART IDENTITY CASCADE ; INSERT INTO pgrouting . edges ( label , length , source , target , cost , reverse_cost , source_data , geom ) SELECT DISTINCT -- label of the edge e . raw_data ->> 'nom_1_g' AS label , -- length ST_length ( e . geom ) AS \"length\" , -- start and end nodes id ns . id , ne . id , -- cost based on the length CASE WHEN e . raw_data ->> 'sens' in ( 'Sans objet' , 'Double sens' , 'Sens direct' ) THEN ST_length ( e . geom ) ELSE - 1 END AS cost , -- reverse cost based on the length CASE WHEN e . raw_data ->> 'sens' in ( 'Sans objet' , 'Double sens' , 'Sens inverse' ) THEN ST_length ( e . geom ) ELSE - 1 END AS reverse_cost , -- Keep some useful columns from the source table jsonb_build_object ( 'id' , e . raw_data -> 'id' , 'nature' , e . raw_data -> 'nature' , 'importance' , e . raw_data -> 'importance' , 'etat' , e . raw_data -> 'etat' , 'largeur' , e . raw_data -> 'largeur' , 'prive' , e . raw_data -> 'prive' , 'sens' , e . raw_data -> 'sens' , 'vit_moy_vl' , e . raw_data -> 'vit_moy_vl' , 'acces_vl' , e . raw_data -> 'acces_vl' ) AS source_data , -- geometry. Needed for the astar route engine e . geom FROM temp_edges AS e LEFT JOIN pgrouting . nodes AS ns -- = is faster than ST_Equals ON ns . geom = e . start_point LEFT JOIN pgrouting . nodes AS ne ON ne . geom = e . end_point ; -- Drop the temporary tables DROP TABLE IF EXISTS temp_nodes ; DROP TABLE IF EXISTS temp_edges ; COMMIT ; -- VACUUM and analyse VACUUM ANALYSE pgrouting . nodes ; VACUUM ANALYSE pgrouting . edges ;","title":"Import the road data into PgRouting graph (nodes and edges)"},{"location":"configuration/#import-data-in-the-poi-tables-optional","text":"Here is an example based on a points of interest layer loaded in a table called your_schema.point_of_interest . This query fill the pgrouting.routing_poi table. In the SELECT you can replace the fields by your fields of your point of interest layer. 1 2 3 INSERT INTO pgrouting . routing_poi ( label , type , description , geom ) SELECT poi . label , poi . type , poi . description , poi . geom FROM your_schema . point_of_interest AS poi ;","title":"Import data in the POI tables (optional)"},{"location":"configuration/#in-qgis","text":"","title":"In QGIS"},{"location":"configuration/#configure-the-qgis-project","text":"To use the pgrouting module in Lizmap Web Client you must first configure a QGIS project : We offer you here a basic project which contains only the layers required and configured for Lizmap. If you want create your project or use another existing project to use this module: Add the Edges and Nodes layers The QGIS project must be called pgrouting.qgs You must then create a configuration for Lizmap with the Lizmap plugin . No specific configuration is needed for the module. You can configure like you want or just click on the apply button.","title":"Configure the QGIS project"},{"location":"contributing/","text":"Contribution # You can contribute to the SQL code or the frontend Lizmap interface.","title":"Contribution"},{"location":"contributing/#contribution","text":"You can contribute to the SQL code or the frontend Lizmap interface.","title":"Contribution"},{"location":"installation/","text":"requirements # a Postgresql database with the pgrouting extension Lizmap 3.5 or above Installation # Automatic installation of files with Composer # into lizmap/my-packages , create the file composer.json (if it doesn't exist) by copying the file composer.json.dist , and install the modules with Composer: 1 2 cp -n lizmap/my-packages/composer.json.dist lizmap/my-packages/composer.json composer require --working-dir = lizmap/my-packages \"lizmap/lizmap-pgrouting-module\" Manual installation of files without Composer # Get the last ZIP archive in the repository page . Extract the archive and copy the pgrouting directory in Lizmap Web Client folder lizmap/lizmap-modules/ With Lizmap 3.5 or lower: edit the config file lizmap/var/config/localconfig.ini.php and add into the section [modules] : 1 pgrouting.access = 2 Launching the installer with Lizmap 3.6 # If you are using Lizmap 3.6 or higher, execute 1 php lizmap/install/configurator.php pgrouting It will ask you all parameters for the database access and the SRID you are using. Then, execute Lizmap install scripts into lizmap/install/ : 1 2 3 php lizmap/install/installer.php ./lizmap/install/clean_vartmp.sh ./lizmap/install/set_rights.sh Launching the installer with Lizmap 3.5 # If you are using a SRID other than 2154, edit the config file lizmap/var/config/localconfig.ini.php and add into the section [modules] : 1 pgrouting.installparam = \"srid=2154\" You can replace 2154 by another SRID that you use. You need to configure the database access in your Lizmap configuration. Add in lizmap/var/config/profiles.ini.php the following parameters. 1 2 3 4 5 6 7 8 9 [jdb:pgrouting] driver = pgsql host = pgsql port = 5432 database = lizmap user = lizmap password = \"yourpassword\" search_path = pgrouting,public Only replace host, database, user and password values. Then, execute the Lizmap install scripts into lizmap/install/ : 1 2 3 php lizmap/install/installer.php ./lizmap/install/clean_vartmp.sh ./lizmap/install/set_rights.sh","title":"Installation"},{"location":"installation/#requirements","text":"a Postgresql database with the pgrouting extension Lizmap 3.5 or above","title":"requirements"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#automatic-installation-of-files-with-composer","text":"into lizmap/my-packages , create the file composer.json (if it doesn't exist) by copying the file composer.json.dist , and install the modules with Composer: 1 2 cp -n lizmap/my-packages/composer.json.dist lizmap/my-packages/composer.json composer require --working-dir = lizmap/my-packages \"lizmap/lizmap-pgrouting-module\"","title":"Automatic installation of files with Composer"},{"location":"installation/#manual-installation-of-files-without-composer","text":"Get the last ZIP archive in the repository page . Extract the archive and copy the pgrouting directory in Lizmap Web Client folder lizmap/lizmap-modules/ With Lizmap 3.5 or lower: edit the config file lizmap/var/config/localconfig.ini.php and add into the section [modules] : 1 pgrouting.access = 2","title":"Manual installation of files without Composer"},{"location":"installation/#launching-the-installer-with-lizmap-36","text":"If you are using Lizmap 3.6 or higher, execute 1 php lizmap/install/configurator.php pgrouting It will ask you all parameters for the database access and the SRID you are using. Then, execute Lizmap install scripts into lizmap/install/ : 1 2 3 php lizmap/install/installer.php ./lizmap/install/clean_vartmp.sh ./lizmap/install/set_rights.sh","title":"Launching the installer with Lizmap 3.6"},{"location":"installation/#launching-the-installer-with-lizmap-35","text":"If you are using a SRID other than 2154, edit the config file lizmap/var/config/localconfig.ini.php and add into the section [modules] : 1 pgrouting.installparam = \"srid=2154\" You can replace 2154 by another SRID that you use. You need to configure the database access in your Lizmap configuration. Add in lizmap/var/config/profiles.ini.php the following parameters. 1 2 3 4 5 6 7 8 9 [jdb:pgrouting] driver = pgsql host = pgsql port = 5432 database = lizmap user = lizmap password = \"yourpassword\" search_path = pgrouting,public Only replace host, database, user and password values. Then, execute the Lizmap install scripts into lizmap/install/ : 1 2 3 php lizmap/install/installer.php ./lizmap/install/clean_vartmp.sh ./lizmap/install/set_rights.sh","title":"Launching the installer with Lizmap 3.5"}]}